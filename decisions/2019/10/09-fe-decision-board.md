# Front-end Decision Board, 2019-10-09

**Attending**: Viktor, Ismay, Hendrik, Jennifer, Jan, Jan-Gerke, Austin,
Joakim S., Erik, Birk, Edoardo

## Topics

### Help each other stay on topic in a discussion, split side topics into new issues

**Conclusion**: Since GitHub Issues are linear, it is difficult to keep
track of discussions if it starts to deviate away from the original
issue. If that happens, we should not be shy about suggesting to move
the _new_ discussion to a separate issue.

Once that's done and all the comments have been moved to the new
discussion, they can be hidden or removed from the original issue to
make it easier to follow.

Think of each issue in GitHub as a single thread.

### ESlint config generated by d2 style js install #52

**Conclusion**: It is [possible to customise the ESLInt
rules](https://github.com/dhis2/cli-style#eslint) that
`d2-style` applies when running its checks and balances. It was
introduced in version 4.0.0 so make sure you are on the latest major
version to access the functionality. [>=4.1.3 is strongly
recommended](https://github.com/dhis2/cli-style/releases/tag/v4.1.3).

Now we want to implement support for project-specific configuration
files, e.g. `project/react` to get all the special React ESLint rules,
and an open question was how to deal with the dependencies. There are
two proposals:

1. Bundle the dependencies in `d2-style` so the consumer doesn't have to
   think about it.

2. Print a list of required dependencies that the consumer will have to
   satisfy manually.

The primary pros and cons raised for **(1)** were:

- :heavy_plus_sign: Simple implementation.
- :heavy_plus_sign: Easier to manage dependency versions.
- :heavy_plus_sign: Inline with how the rest of `d2-style` works (batteries included).
- :heavy_minus_sign: Potentially un-used dependencies installed into
  the consumers `node_modules/`.
- :heavy_minus_sign: Longer install time for `d2-style` because there's
  simply more runtime deps.

For option **(2)**:

- :heavy_plus_sign: No stale/un-used dependencies in `node_modules/`.
- :heavy_plus_sign: Smaller install size for `d2-style`.
- :heavy_minus_sign: Difficult to maintain versions of supported plugins
  and catch discrepencies.
- :heavy_minus_sign: User needs to be aware that she needs to install
  additional deps after enabling e.g. `project/react` config.
- :heavy_minus_sign: Requires a more complex implementation to work.

Since option **(1)** is closer to the vision of the `d2-style` tool, we
will start with that solution, and if the size of the installed tool
gets out of hand, we will have to re-think the approach.

### Unified form handling #25

**Conclusion**: Going forward with
[`dhis2/ui-forms`](https://github.com/dhis2/ui-core/pull/430) as is.
Work on it is currently on hold as some required components are being
re-worked and developed for the next major version of
[`dhis2/ui-core`](https://github.com/dhis2/ui-core/pull/430), so now is
a _great time_ to go through `ui-forms` and get involved!

### Slow down releases a bit, improve automation

**Conclusion**: The proposal was rejected. This was in part due to
wishes to not split the manual workflow in two by having e.g.
squash-merges to `develop` and merges to `master`.

On hindsight there are multiple issues conflated in this topic:

- Allow Dependabot **automatic merges** of certain dependencies to handle
  the avalanche of dependency updates.

- Allow a developer to **defer the automatic release system** for a
  short amount of time to bundle commits into the same release.

- Allow the developer to **use the same workflow everywhere** so she
  doesn't have to keep track of what to do when in 40+ repos.

Going through them one by one:

#### Automatic merges

**Trial**: Allow Dependabot to merge a sub-set of dependencies to
`master` in a low-risk repository:
[cli-style](https://github.com/dhis2/cli-style)

The up-to-date automerged dependencies can be seen in
[`cli-style/.dependabot/config.yml`](https://github.com/dhis2/cli-style/blob/master/.dependabot/config.yml)
at any time. At the time of writing the strategy is to automatically
merge any **minor** updates to any `@dhis2` scoped package and merge all
**patch** versions for known security fixes. Others will be manually
handled.

Will run the trial for 1 week in **cli-style** before rolling out to
**ui-widgets**. If everything keeps going all right we will identify
another candidate from the [Dependabot enabled
repos](https://app.dependabot.com/accounts/dhis2).

#### Defer the automatic release system

There are a few options of varying complexity:

- The proposed workflow in the agenda.

- Bundle multiple changes on the same branch before merging to `master`.

- Using `[skip ci]` in a commit message to, well, skip CI, which will
  also skip the `semantic-release` process.

- Implementing another commit message tag, e.g. `[defer release]` to
  still run the CI checks, but skip the `semantic-release` process. [A PR
  for it has been posted](https://github.com/dhis2/cli/pull/161).

The `[skip ci]` and `[defer release]` options are different variations
of the same, so we will go ahead with one of them. If the defer-release
PR is accepted, we will use that. If not, we will use skip-ci.

#### Use the same workflow everywhere

Currently we use "squash-merge" as our default strategy, and we also use
`next` branches to merge multiple fixes/features to `master` at the same
time.

There is a significant downside of this in terms of how the changelogs
are generated.

This commit was merged from `next` to `master` to release version 3.0.0
of `@dhis2/ui-core`:
https://github.com/dhis2/ui-core/commit/6df182bdbb1de8b80d76ac7677a1a37478aa8da6

The commit message itself is nicely formatted and has a list of all the
changes, but the CHANGELOG is quite sparse:
https://github.com/dhis2/ui-core/blob/master/CHANGELOG.md#300-2019-06-06

It contains a single `chore` and lists the breaking change. In order to
get all the commits into the changelog, they must land on `master` as
well. We can use the `[skip ci]`/`[defer release]` tag to do that when
there are two or three PRs to merge after eachother, but when there are
[69 commits bundled into one
release](https://github.com/dhis2/ui-core/pull/430/commits) that is not
an option.

Given that we want:

- Linear history on `master` (no merge commits)
- One commit per feature/fix
- Option for bundling changes for a release
- Precise changelogs

Then the "rebase-merge" strategy is a good option:

- We can enforce that _all_ commits on a branch are semantic commits as
  as status check (using **probot-semantic-pull-requests** currently enabled
  in all repositories).

- No need to ever provide a manual commit message in GitHub when
  merging a PR.

- "rebase-merge" is not a true rebase on GitHub, it results in a
  fast-forward merge just like "squash-merge".

- If a PR contains multiple commits, they will land as-is on `master`
  and show up in the changelog correctly, so we can have a `fix` and
  `feat` in the same PR.

- If a PR contains a single commit, it will also land as-is on `master`.

- It is up to the developer to decide if a PR should be squashed before
  merging it, and that will need to be done locally.
  
- Locally squashing has the added safety net of re-running the semantic
  commit checks, something the "squash-merge" in GitHub cannot do.

**Trial**: We will start using the "rebase-merge" workflow on a couple
of different repositories before deciding if it works for us or not.

##### Repos and rationale:

1. `dhis2/cli-style`: small and self-contained repo, used to verify that
   Dependabot can still merge PRs, and has automatic release to NPM.

2. `dhis2/app-store`: self-contained and works with feature branches,
   has automatic deployment to production on AWS.

3. `dhis2/ui-core`: Automatically deploys to NPM, has a lot of activity
   in all types (fix, feature, breaking changes), and has an upcoming
   `next` branch with many commits that will land and be documented in
   the changelog.

##### Known issues and workarounds:

- Do not leave a comment saying "@dependabot squash and merge" when
  approving a Dependabot PR. We only need to give it an approving review
  with an empty comment to signal to Dependabot to merge the PR. If we
  tell it to "squash and merge" on a "rebase and merge" PR, then
  Dependabot remembers that forever, and it will always fail to
  squash-merge it.

  The workaround is to manually hit merge.

- When using the GitHub feature to "Update branch" with `master`, GitHub
  creates a merge commit with a non-semantic commit message like "Merge
  branch '{branch}' into {branch}". The Semantic Pull Requests bot is
  going to see that the branch now has a non-semantic commit and will
  not let you merge that to master.

  The workaround is to update your branch locally using a semantic
  commit message, or, locally changing the non-semantic commit message
  through something like: `git commit --amend && git push origin HEAD
  --force-with-lease`.
